#include <gb/gb.h>
#include <rand.h>

#define RGB_RED        RGB(31,  0,  0)
#define RGB_DARKRED    RGB(16,  0,  0)
#define RGB_GREEN      RGB( 0, 31,  0)
#define RGB_BLUE       RGB( 0,  0, 31)
#define RGB_DARKBLUE   RGB( 0,  0, 16)
#define RGB_PURPLE     RGB(21,  0, 21)
#define RGB_DARKPURPLE RGB(16,  0, 16)
#define RGB_LAVENDER   RGB(48,  0, 48)

#define GHOST_ANIM_SPEED 5
#define GHOST_TILE_OFFSET 0
#define WALL_TILE_OFFSET 12
#define STARTX 80 //center object horizontally ([160 / 2])
#define STARTY 72 //center vertically ([144 / 2])

const unsigned char ghost[] =
{
  0x01,0x01,0x02,0x03,0x05,0x06,0x0B,0x0C,
  0x17,0x18,0x3F,0x20,0x7F,0x40,0x67,0x58,
  0xEF,0x98,0x93,0xFC,0x90,0xFF,0xD0,0xFF,
  0x30,0x3F,0x0A,0x0F,0x04,0x07,0x07,0x07,
  0xF0,0xF0,0x08,0xF8,0xF4,0x0C,0xFE,0x12,
  0xFC,0x32,0xFC,0x33,0xFF,0x01,0xFD,0x03,
  0xF8,0x0E,0xFE,0x0E,0xFC,0x04,0x08,0xF8,
  0x30,0xF0,0x40,0xC0,0x80,0x80,0x00,0x00,
  0x01,0x01,0x02,0x03,0x05,0x06,0x0B,0x0C,
  0x17,0x18,0x1F,0x10,0x1F,0x10,0x2F,0x30,
  0xDF,0xE0,0xBE,0xC1,0x8C,0xF3,0x40,0x7F,
  0x31,0x3F,0x09,0x0F,0x06,0x07,0x01,0x01,
  0xF0,0xF0,0x08,0xF8,0xF4,0x0C,0xFE,0x12,
  0xFC,0x32,0xFC,0x33,0xFF,0x01,0xFD,0x03,
  0xF8,0x0E,0x7E,0x8E,0x7C,0x84,0x88,0xF8,
  0x10,0xF0,0x20,0xE0,0x40,0xC0,0x80,0x80,
  0x01,0x01,0x02,0x03,0x05,0x06,0x0B,0x0C,
  0x17,0x18,0x1F,0x10,0x1F,0x10,0x2F,0x30,
  0x3D,0x22,0x39,0x26,0x52,0x6F,0xC4,0xFF,
  0x24,0x3F,0x18,0x1F,0x06,0x07,0x01,0x01,
  0xF0,0xF0,0x08,0xF8,0xF4,0x0C,0xFE,0x12,
  0xFC,0x32,0xFC,0x33,0xFF,0x01,0xFD,0x03,
  0xF8,0x0E,0xFE,0x0E,0x7C,0x84,0x08,0xF8,
  0x10,0xF0,0x10,0xF0,0x20,0xE0,0xC0,0xC0
};

const unsigned char walls[] =
{
  0xFF,0xFF,0x87,0x7C,0x06,0xFD,0x04,0xFF,
  0xFF,0xFF,0x3C,0xE3,0x30,0xEF,0x20,0xFF,
  0xFF,0xFF,0xFF,0x01,0xFD,0x03,0xC1,0x3F,
  0xC1,0x3F,0xC1,0x3F,0xC3,0x3F,0x87,0x7F
};

const unsigned char score[] =
{
  0xFE,0xFE,0xFF,0x83,0xFF,0x83,0xFF,0x93,
  0xFF,0x93,0xFF,0x93,0xFF,0x93,0xFF,0x93,
  0xFF,0x93,0xFF,0x93,0xFF,0x93,0xFF,0x93,
  0xFF,0x83,0xFF,0x83,0xFF,0xFF,0x7F,0x7F,
  0x7C,0x7C,0x7E,0x46,0x7E,0x46,0x7E,0x46,
  0x7E,0x46,0x7E,0x46,0x7E,0x46,0x7E,0x46,
  0x7E,0x46,0x7E,0x46,0x7E,0x46,0x7E,0x46,
  0x7E,0x46,0x7E,0x46,0x7E,0x7E,0x3E,0x3E,
  0xFE,0xFE,0xFF,0x83,0xFF,0x83,0xFF,0x83,
  0xFF,0xE3,0xFF,0xE3,0xFF,0x83,0xFF,0x83,
  0xFF,0x83,0xFF,0x8F,0xFF,0x8F,0xFF,0x83,
  0xFF,0x83,0xFF,0x83,0xFF,0xFF,0x7F,0x7F,
  0xFE,0xFE,0xFF,0x83,0xFF,0x83,0xFF,0x83,
  0xFF,0xE3,0xFF,0xE3,0xFF,0x83,0xFF,0x83,
  0xFF,0x83,0xFF,0xE3,0xFF,0xE3,0xFF,0x83,
  0xFF,0x83,0xFF,0x83,0xFF,0xFF,0x7F,0x7F,
  0xFE,0xFE,0xFF,0x93,0xFF,0x93,0xFF,0x93,
  0xFF,0x93,0xFF,0x93,0xFF,0x83,0xFF,0x83,
  0xFF,0xF3,0x1F,0x13,0x1F,0x13,0x1F,0x13,
  0x1F,0x13,0x1F,0x13,0x1F,0x1F,0x0F,0x0F,
  0xFE,0xFE,0xFF,0x83,0xFF,0x83,0xFF,0x83,
  0xFF,0x8F,0xFF,0x8F,0xFF,0x83,0xFF,0x83,
  0xFF,0x83,0xFF,0xE3,0xFF,0xE3,0xFF,0x83,
  0xFF,0x83,0xFF,0x83,0xFF,0xFF,0x7F,0x7F,
  0xFE,0xFE,0xFF,0x83,0xFF,0x83,0xFF,0x83,
  0xFF,0x8F,0xFF,0x8F,0xFF,0x83,0xFF,0x83,
  0xFF,0x83,0xFF,0x93,0xFF,0x93,0xFF,0x83,
  0xFF,0x83,0xFF,0x83,0xFF,0xFF,0x7F,0x7F,
  0xFE,0xFE,0xFF,0x83,0xFF,0x83,0xFF,0x83,
  0xFF,0xF3,0x1F,0x13,0x1F,0x13,0x1F,0x13,
  0x1F,0x13,0x1F,0x13,0x1F,0x13,0x1F,0x13,
  0x1F,0x13,0x1F,0x13,0x1F,0x13,0x0F,0x0F,
  0xFE,0xFE,0xFF,0x83,0xFF,0x83,0xFF,0x93,
  0xFF,0x93,0xFF,0x93,0xFF,0x83,0xFF,0x83,
  0xFF,0x83,0xFF,0x93,0xFF,0x93,0xFF,0x93,
  0xFF,0x83,0xFF,0x83,0xFF,0xFF,0x7F,0x7F,
  0xFE,0xFE,0xFF,0x83,0xFF,0x83,0xFF,0x93,
  0xFF,0x93,0xFF,0x93,0xFF,0x83,0xFF,0x83,
  0xFF,0xF3,0x1F,0x13,0x1F,0x13,0x1F,0x13,
  0x1F,0x13,0x1F,0x13,0x1F,0x1F,0x0F,0x0F
};

const unsigned char button[] =
{
  0x00,0x00,0x00,0x00,0x03,0x03,0x0F,0x0C,
  0x1F,0x18,0x1F,0x11,0x3F,0x22,0x3F,0x23,
  0x3F,0x22,0x3F,0x22,0x1F,0x30,0x1F,0x38,
  0x0F,0x3C,0x03,0x1F,0x00,0x0F,0x00,0x03,
  0x00,0x00,0x00,0x00,0xC0,0xC0,0xF0,0x30,
  0xF8,0x18,0xF8,0x88,0xFC,0x44,0xFC,0xC4,
  0xFC,0x44,0xFC,0x44,0xF8,0x0C,0xF8,0x1C,
  0xF0,0x3C,0xC0,0xF8,0x00,0xF0,0x00,0xC0
};

const unsigned char tiles[] =
{
  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
  0x00,0xFF,0x78,0x04,0xF9,0x04,0xFB,0x04,
  0x00,0xFF,0xC3,0x20,0xCF,0x20,0xDF,0x20,
  0x00,0xFF,0x00,0x01,0x02,0x01,0x3E,0x01,
  0x3E,0x01,0x3E,0x01,0x3C,0x03,0x78,0x07,
  0x70,0x80,0x7F,0x80,0x80,0xFF,0xFF,0xFF,
  0x1C,0x10,0xF7,0x18,0xF7,0x18,0xF7,0x18
}; 

const unsigned char bgmap[] =
{
  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
  0x00,0x00,0x00,0x00,0x03,0x03,0x03,0x03,0x03,0x03,
  0x03,0x03,0x03,0x03,0x03,0x03,0x03,0x03,0x03,0x03,
  0x03,0x03,0x03,0x03,0x03,0x03,0x03,0x03,0x03,0x03,
  0x03,0x03,0x03,0x03,0x03,0x03
};

const unsigned char wall_map[] =
{
  0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,
  0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,
  0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,
  0x01,0x01,0x01,0x01,0x01,0x01
};
const unsigned char nowall_map[] =
{
  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
  0x00,0x00,0x00,0x00,0x01,0x01
};

const UWORD spritePalette[] = {
	0, RGB_LAVENDER, RGB_PURPLE, RGB_DARKPURPLE,
	0, RGB_GREEN, RGB_BLUE, RGB_PURPLE
};

enum GAME_STATE {GAME_MENU, PRE_PLAY, PLAY, GAME_OVER, RESET};
const UINT8 xspeed = 2;
UINT8 counter,y,anim_frame, button_frame, anim_counter, grav_counter, wall_x, wall_rand, current_score, wall_tiles_location;
UINT8 is_pressed_J_A;
INT8 yspeed;
enum GAME_STATE current_state;

void init_all_sprites();
void reset_all_sprites();
void update_ghost_sprites();
void update_wall_sprites();
void update_score();
void check_coll();
void animate_ghost();
void play_sound_jump();
void play_sound_crash();

void main()
{

	disable_interrupts();
	DISPLAY_OFF;
	
	current_state = GAME_MENU;
	yspeed = 0;
	is_pressed_J_A = 0;
	wall_rand=0;
	current_score = 0x00;
	// load background
	set_bkg_data(0,4,tiles);
	set_bkg_tiles( 0, 0, 32, 18, bgmap);
	
	SPRITES_8x8;
	init_all_sprites();
	anim_frame=0;
	anim_counter = 0;
	grav_counter = 0;
	wall_x = 232U;//track wall location
	y = STARTY;
	reset_all_sprites();

	NR52_REG = 0x80U; //Turns on sound hardware
	NR51_REG = 0x99U; //turn channels 1 and 3 on, 2 and 3 off
	NR50_REG = 0x77U; //Sets volume to max for left and right speakers
	
	initrand((UINT16)DIV_REG);	

	SHOW_BKG;
	SHOW_SPRITES; 
	DISPLAY_ON;
	enable_interrupts();

	while(1) {
		wait_vbl_done();//skip a frame for speed reasons. not the best solution, but an easy one
		wait_vbl_done();
		switch(current_state)
		{
			case GAME_MENU:
			{
				current_state = PRE_PLAY;
				break;
			}
			case PRE_PLAY:
			{
				anim_counter++; //count gameplay frames that elapse.
				
				//Get and respond to joypad input
				counter = joypad();
				if(counter & J_A)
				{
					if(is_pressed_J_A == 0)//used to only respond to the inital press of the button, not to held buttons
					{
						yspeed = (INT8)-4; //if A pressed, jump by setting yspeed to -4
						grav_counter = 0; //reset gravity wait counter when jumping, gives consistent jump results

						move_sprite(28,112,0); //move button off screen
						move_sprite(29,112,0);
						move_sprite(30,120,0);
						move_sprite(31,120,0);

						play_sound_jump();
						wall_x = 232U;
						//update_wall_sprites();
						current_state = PLAY;
					}
					is_pressed_J_A = 1; //note that we're holding the button down now
				}
				else
				{
					is_pressed_J_A = 0; //A isn't pressed, make sure we properly set out state tracker for it
				}
				scroll_bkg(xspeed,0); //move background tiles left relative to current position
				//wall_x-=xspeed;
				animate_ghost();
				update_ghost_sprites();
				break;
			}
			case PLAY:
			{
				grav_counter++;//apply gravity to ghost every other tick
				if(grav_counter == 2)
				{
					grav_counter = 0;
					yspeed++;
				}

				anim_counter++; //count gameplay frames that elapse.
				
				//Get and respond to joypad input
				counter = joypad();
				if(counter & J_A)
				{
					if(is_pressed_J_A == 0)//used to only respond to the inital press of the button, not to held buttons
					{
						yspeed = (INT8)-4; //if A pressed, jump by setting yspeed to -4
						grav_counter = 0; //reset gravity wait counter when jumping, gives consistent jump results
						play_sound_jump();
					}
					is_pressed_J_A = 1; //note that we're holding the button down now
				}
				else
				{
					is_pressed_J_A = 0; //A isn't pressed, make sure we properly set out state tracker for it
				}
				wall_x-=xspeed; //wall_x -= 2, used to track walls shifting left 2 pixels/cycle
				update_wall_sprites();		
				scroll_bkg(xspeed,0); //move background tiles left relative to current position
				animate_ghost();
				update_ghost_sprites();

				check_coll();

				break;
			}
			case GAME_OVER:
			{
				//slide to bottom of screen
				if(y < 141)
					yspeed = 1;
				else
					yspeed = 0;
				update_ghost_sprites();
				counter = joypad();
				if((counter & J_A))
				{
					if(is_pressed_J_A == 0)
					{
						current_state = RESET;
					}
					is_pressed_J_A = 1;
				}
				else
				{
					is_pressed_J_A = 0;
				}
				break;
			}
			case RESET:
			{
				yspeed = 0;
				//is_pressed_J_A = 0;
				wall_rand=0;
				current_score = 0x00;
				anim_frame=0;
				anim_counter = 0;
				grav_counter = 0;
				current_score = 0;
				wall_x = 232U; //track wall location
				y = STARTY;
				reset_all_sprites();
				//set_bkg_tiles((UINT8)wall_tiles_location, (UINT8)wall_rand+2, (UINT8)2, (UINT8)8, nowall_map);//erase old wall tiles
				current_state = PRE_PLAY;
				break;
			}
			default:
				break;
		}
	}
}

void init_all_sprites()
{
	set_sprite_palette(0, 2, spritePalette);
	set_sprite_data(0, 12, ghost);//load tiles for ghost sprites
	for(counter = 0; counter < 12; counter++)
		set_sprite_prop(counter, 0);
	set_sprite_data(12, 2, walls);//load tiles for wall sprites
	
	set_sprite_data(14, 20, score);//load tiles for score sprites
	set_sprite_data(34, 4, button);
}

void reset_all_sprites()
{
	//Setup Ghost mega-sprite
	set_sprite_tile(0,0);//define and place all 4 sprites in the mega sprite
	move_sprite(0,STARTX,STARTY);
	set_sprite_tile(1,1);
	move_sprite(1,STARTX,STARTY+8);
	set_sprite_tile(2,2);
	move_sprite(2,STARTX+8,STARTY);
	set_sprite_tile(3,3);
	move_sprite(3,STARTX+8,STARTY+8);

	//make wall sprites
	for (counter = 4; counter < 20; counter++)
	{
		set_sprite_tile(counter, 12); 
	}

	//make wall capstone sprites
	for (counter = 20; counter < 24; counter++)
	{
		set_sprite_tile(counter, 13); 
	}

	for (counter = 4; counter < 8; counter++)//move wall tiles
	{
		if ((wall_rand+(counter-5)) > 1)
			move_sprite(counter, wall_x, (wall_rand+(counter-5)) << 3);
		else
			move_sprite(counter, wall_x, (wall_rand+(counter+13)) << 3);
	}
	for (counter = 8; counter < 12; counter++)
	{
		if((wall_rand+(counter-9)) > 1)
			move_sprite(counter, wall_x+8, (wall_rand+(counter-9)) << 3);
		else
			move_sprite(counter, wall_x+8, (wall_rand+(counter+9)) << 3);
	}
	for (counter = 12; counter < 16; counter++)
	{
		if(wall_rand+(counter+2) < 20)
			move_sprite(counter, wall_x, (wall_rand+(counter+2)) << 3);
		else
			move_sprite(counter, wall_x, (wall_rand+(counter-16)) << 3);
	}
	for (counter = 16; counter < 20; counter++)
	{
		if(wall_rand+(counter-2) < 20)
			move_sprite(counter, wall_x+8, (wall_rand+(counter-2)) << 3);
		else
			move_sprite(counter, wall_x+8, (wall_rand+(counter-20)) << 3);
	}
	move_sprite(20, wall_x, (wall_rand+3) << 3); //move capstone tiles
	move_sprite(21, wall_x+8, (wall_rand+3) << 3);
	move_sprite(22, wall_x, (wall_rand+13) << 3);
	move_sprite(23, wall_x+8, (wall_rand+13) << 3);

	set_sprite_tile(24, 14); //set right digit to 0
	set_sprite_tile(25, 15);
	move_sprite(24,88,24); //place right digit in center
	move_sprite(25,88,32);
	set_sprite_tile(26, 14);//set left digit to 0
	set_sprite_tile(27, 15);
	move_sprite(26,80,0);//move left digit off screen for now
	move_sprite(27,80,8);

	//set button
	set_sprite_tile(28, 34);
	set_sprite_tile(29, 35);
	set_sprite_tile(30, 36);
	set_sprite_tile(31, 37);

	move_sprite(28,112,68); //move button
	move_sprite(29,112,76);
	move_sprite(30,120,68);
	move_sprite(31,120,76);
}

void update_ghost_sprites()
{
	y += yspeed;
	if(y < 16)
	{
		y = 16;
		move_sprite(0,STARTX,y);
		set_sprite_tile(1,1);
		move_sprite(1,STARTX,y+8);
		set_sprite_tile(2,2);
		move_sprite(2,STARTX+8,y);
		set_sprite_tile(3,3);
		move_sprite(3,STARTX+8,y+8);
	}
	else
	{
		//move ghost sprites second (draw in order hopefully)
		for(counter = 0; counter < 4; counter++)
		{
			scroll_sprite(counter,0,yspeed); //move all 4 ghost sprites relative to current position
		}
	}
}

void update_wall_sprites()
{
	switch(wall_x)
	{
		case 224U: //randomize wall when it's off screen
		{
			wall_rand = ((UINT8)rand() & 7); //calculate new random height offset, modulus 8
			if (wall_rand > 5U)
				wall_rand = 5U;	
			wall_tiles_location = (SCX_REG >> 3U) + 27U;
			//set_bkg_tiles(wall_tiles_location,(UINT8)wall_rand+2,(UINT8)2,(UINT8)8,wall_map);
			wall_x -= (UINT8)(SCX_REG & 7U);			
			for (counter = 4; counter < 8; counter++)//move wall tiles
			{
				if ((wall_rand+(counter-5)) > 1)
					move_sprite(counter, wall_x, (wall_rand+(counter-5)) << 3);
				else
					move_sprite(counter, wall_x, (wall_rand+(counter+13)) << 3);
			}
			for (counter = 8; counter < 12; counter++)
			{
				if((wall_rand+(counter-9)) > 1)
					move_sprite(counter, wall_x+8, (wall_rand+(counter-9)) << 3);
				else
					move_sprite(counter, wall_x+8, (wall_rand+(counter+9)) << 3);
			}
			for (counter = 12; counter < 16; counter++)
			{
				if(wall_rand+(counter+2) < 20)
					move_sprite(counter, wall_x, (wall_rand+(counter+2)) << 3);
				else
					move_sprite(counter, wall_x, (wall_rand+(counter-16)) << 3);
			}
			for (counter = 16; counter < 20; counter++)
			{
				if(wall_rand+(counter-2) < 20)
					move_sprite(counter, wall_x+8, (wall_rand+(counter-2)) << 3);
				else
					move_sprite(counter, wall_x+8, (wall_rand+(counter-20)) << 3);
			}
			move_sprite(20, wall_x, (wall_rand+3) << 3); //move capstone tiles
			move_sprite(21, wall_x+8, (wall_rand+3) << 3);
			move_sprite(22, wall_x, (wall_rand+13) << 3);
			move_sprite(23, wall_x+8, (wall_rand+13) << 3);
			break;
		}
		case 80:
		{
			current_score++;
			if(current_score > 0x99)
				current_score = 0x99;
			if((current_score & 0x0f) > 0x09)
			{
				current_score+=6;
			}
			update_score();
			break;
		}
		default:
			break;
	}
	//move wall sprites
	for(counter = 4; counter < 24; counter++)
	{
		//move wall each time it's off screen
		scroll_sprite(counter, -xspeed, 0); // move wall 2 pixels left
	}
}

void update_score()
{
	set_sprite_tile(24, 14 + ((current_score & 0x0f) << 1));
	set_sprite_tile(25, 15 + ((current_score & 0x0f) << 1));
	if(current_score > 0x09)
	{
		set_sprite_tile(26, 14 + ((current_score & 0xF0) >> 3));
		set_sprite_tile(27, 15 + ((current_score & 0xF0) >> 3));
		if(current_score == 0x10)
		{
			move_sprite(26,80,24);
			move_sprite(27,80,32);
		}
	}
}

void check_coll()
{
	//really janky collision detection
	//we check if the wall is in a range where we could touch
	//then we see if our height is too low or too high
	//that's it

	if(wall_x < 96 && wall_x > 67) //pretty sure that's our overlap
	{
		if(((wall_rand+4 << 3) > y) || ((wall_rand+11 << 3) < y-3))
		{
			play_sound_crash();
			current_state = GAME_OVER;
		}

	}
	else if(y > 140)
	{
		play_sound_crash();
		current_state = GAME_OVER;
	}
}

void animate_ghost()
{
	if(anim_counter > GHOST_ANIM_SPEED)  //if enough game play frames have elapsed, update ghost animation
	{
		anim_counter = 1; //reset frame counter
		if(anim_frame < 2) //loop through sprite frames
		{
			anim_frame++;
		}
		else
		{
			anim_frame = 0;
		}
		set_sprite_tile(0,0 + (anim_frame << 2)); //iterate the sprites according to the animation frame tracker. 
		set_sprite_tile(1,1 + (anim_frame << 2)); //there are 4 8x8 sprites in the ghost mega-sprite,
		set_sprite_tile(2,2 + (anim_frame << 2)); //so the "<< 2" is to multiply by four, accounting for that offset
		set_sprite_tile(3,3 + (anim_frame << 2));

	}
}

void play_sound_jump()
{
	//channel 1 and 4 register settings found through trial and error using the updated sound demo by Zal0
	//I have no idea what they mean individually, but they work
	NR10_REG = 0x76U;
	NR11_REG = 0x80U;
	NR12_REG = 0x53U;
	NR13_REG = 0xFAU;
	NR14_REG = 0x85U;
	
	
	NR41_REG = 0x00U;
	NR42_REG = 0x31U;
	NR43_REG = 0x30U;
	NR44_REG = 0x80U;

}

void play_sound_crash()
{
	//channel 4 register settings found through trial and error using the updated sound demo by Zal0
	//I have no idea what they mean individually, but they work
	NR10_REG = 0x7BU;
	NR11_REG = 0x41U;
	NR12_REG = 0x57U;
	NR13_REG = 0xDCU;
	NR14_REG = 0x85U;
	
	NR41_REG = 0x10U;//0x3FU;
	NR42_REG = 0x71U;
	NR43_REG = 0x61U;
	NR44_REG = 0xC0U;
}