\section{stdio.h File Reference}
\label{stdio.h}\index{stdio.h@{stdio.h}}
Basic file/console input output functions. 


\subsection*{Functions}
\begin{CompactItemize}
\item 
\label{stdio.h_a0}
\index{putchar@{putchar}!stdio.h@{stdio.h}}\index{stdio.h@{stdio.h}!putchar@{putchar}}
void {\bf putchar} (char c)
\begin{CompactList}\small\item\em Put the character 'c' to stdout.\item\end{CompactList}

\item 
void {\bf printf} (const char $\ast$format, ...) NONBANKED
\begin{CompactList}\small\item\em Print the string and arguments given by format to stdout.\item\end{CompactList}

\item 
void {\bf sprintf} (char $\ast$str, const char $\ast$format, ...) NONBANKED
\begin{CompactList}\small\item\em Print the string and arguments given by format to a buffer.\item\end{CompactList}

\item 
\label{stdio.h_a3}
\index{puts@{puts}!stdio.h@{stdio.h}}\index{stdio.h@{stdio.h}!puts@{puts}}
void {\bf puts} (const char $\ast$s) NONBANKED
\begin{CompactList}\small\item\em {\bf puts}() {\rm (p.~\pageref{stdio.h_a3})} writes the string s and a trailing newline to std­ out.\item\end{CompactList}

\item 
char$\ast$ {\bf gets} (char $\ast$s)
\begin{CompactList}\small\item\em {\bf gets}() {\rm (p.~\pageref{stdio.h_a4})} reads a line from stdin into the buffer pointed to by s until either a terminating newline or EOF, which it replaces with '$\backslash$0'.\item\end{CompactList}

\item 
\label{stdio.h_a5}
\index{getchar@{getchar}!stdio.h@{stdio.h}}\index{stdio.h@{stdio.h}!getchar@{getchar}}
char {\bf getchar} (void)
\begin{CompactList}\small\item\em {\bf getchar}() {\rm (p.~\pageref{stdio.h_a5})} gets a single character from stdin.\item\end{CompactList}

\end{CompactItemize}
\vspace{0.4cm}\hrule\vspace{0.2cm}
\subsection*{Detailed Description}
Basic file/console input output functions.\vspace{0.4cm}\hrule\vspace{0.2cm}
\subsection*{Function Documentation}
\label{stdio.h_a1}
\index{stdio.h@{stdio.h}!printf@{printf}}
\index{printf@{printf}!stdio.h@{stdio.h}}
\subsection{\setlength{\rightskip}{0pt plus 5cm}void printf (const char $\ast$ {\em format}, ...)}

Print the string and arguments given by format to stdout.

Currently supported: \%c (character), \%u (unsigned int), \%d (signed int), \%x (unsigned int as hex), and \%s (string). Does not return the number of characters printed. \label{stdio.h_a2}
\index{stdio.h@{stdio.h}!sprintf@{sprintf}}
\index{sprintf@{sprintf}!stdio.h@{stdio.h}}
\subsection{\setlength{\rightskip}{0pt plus 5cm}void sprintf (char $\ast$ {\em str}, const char $\ast$ {\em format}, ...)}

Print the string and arguments given by format to a buffer.

Currently supported: \%c (character), \%u (unsigned int), \%d (signed int), \%x (unsigned int as hex), and \%s (string). Does not return the number of characters printed.

\begin{Desc}
\item[{\bf Parameters: }]\par
\begin{description}
\item[
{\em str}] The buffer to print into. \item[
{\em format}] The format string as per printf. \end{description}
\end{Desc}
\label{stdio.h_a4}
\index{stdio.h@{stdio.h}!gets@{gets}}
\index{gets@{gets}!stdio.h@{stdio.h}}
\subsection{\setlength{\rightskip}{0pt plus 5cm}char $\ast$ gets (char $\ast$ {\em s})}

{\bf gets}() {\rm (p.~\pageref{stdio.h_a4})} reads a line from stdin into the buffer pointed to by s until either a terminating newline or EOF, which it replaces with '$\backslash$0'.

No check for buffer overrun is per­ formed. 