.TH gb.h 3 "19 Aug 2000" "gbdk-lib" \" -*- nroff -*-
.ad l
.nh
.SH NAME
gb.h \- Gameboy specific functions. 
.SH SYNOPSIS
.br
.PP
.SS Defines

.in +1c
.ti -1c
.RI "#define \fBJ_START\fR"
.br
.RI "\fIJoypad bits.\fR"
.PP
.in +1c

.ti -1c
.RI "#define \fBM_DRAWING\fR"
.br
.RI "\fIScreen modes.\fR"
.PP
.in +1c

.ti -1c
.RI "
#define \fBM_NO_SCROLL\fR"
.br
.RI "\fISet this in addition to the others to disable scrolling If scrolling is disabled, the cursor returns to (0,0).\fR"
.PP
.in +1c

.ti -1c
.RI "
#define \fBM_NO_INTERP\fR"
.br
.RI "\fISet this to disable \\n interpretation.\fR"
.PP
.in +1c

.ti -1c
.RI "#define \fBS_PALETTE\fR"
.br
.RI "\fIIf this is set, sprite colours come from OBJ1PAL.\fR"
.PP
.in +1c

.ti -1c
.RI "
#define \fBS_FLIPX\fR"
.br
.RI "\fIIf set the sprite will be flipped horizontally.\fR"
.PP
.in +1c

.ti -1c
.RI "
#define \fBS_FLIPY\fR"
.br
.RI "\fIIf set the sprite will be flipped vertically.\fR"
.PP
.in +1c

.ti -1c
.RI "
#define \fBS_PRIORITY\fR"
.br
.RI "\fIIf this bit is clear, then the sprite will be displayed ontop of the background and window.\fR"
.PP
.in +1c

.ti -1c
.RI "#define \fBVBL_IFLAG\fR"
.br
.RI "\fIVertical blank interrupt.\fR"
.PP
.in +1c

.ti -1c
.RI "#define \fBLCD_IFLAG\fR"
.br
.RI "\fIInterrupt when triggered by the STAT register.\fR"
.PP
.in +1c

.ti -1c
.RI "
#define \fBTIM_IFLAG\fR"
.br
.RI "\fIInterrupt when the timer TIMA overflows.\fR"
.PP
.in +1c

.ti -1c
.RI "
#define \fBSIO_IFLAG\fR"
.br
.RI "\fIOccurs when the serial transfer has completed.\fR"
.PP
.in +1c

.ti -1c
.RI "
#define \fBJOY_IFLAG\fR"
.br
.RI "\fIOccurs on a transition of the keypad.\fR"
.PP
.in +1c

.ti -1c
.RI "
#define \fBSCREENWIDTH\fR"
.br
.RI "\fIWidth of the visible screen in pixels.\fR"
.PP
.in +1c

.ti -1c
.RI "
#define \fBSCREENHEIGHT\fR"
.br
.RI "\fIHeight of the visible screen in pixels.\fR"
.PP
.in +1c

.ti -1c
.RI "
#define \fBDMG_TYPE\fR"
.br
.RI "\fIOriginal GB or Super GB.\fR"
.PP
.in +1c

.ti -1c
.RI "
#define \fBMGB_TYPE\fR"
.br
.RI "\fIPocket GB or Super GB 2.\fR"
.PP
.in +1c

.ti -1c
.RI "
#define \fBCGB_TYPE\fR"
.br
.RI "\fIColor GB.\fR"
.PP
.in +1c

.ti -1c
.RI "
#define \fBIO_IDLE\fR"
.br
.RI "\fIIO is completed.\fR"
.PP
.in +1c

.ti -1c
.RI "
#define \fBIO_SENDING\fR"
.br
.RI "\fISending data.\fR"
.PP
.in +1c

.ti -1c
.RI "
#define \fBIO_RECEIVING\fR"
.br
.RI "\fIReceiving data.\fR"
.PP
.in +1c

.ti -1c
.RI "
#define \fBIO_ERROR\fR"
.br
.RI "\fIError.\fR"
.PP
.in +1c

.ti -1c
.RI "#define \fBSWITCH_ROM_MBC1\fR (b) "
.br
.RI "\fISwitches the upper 16k bank of the 32k rom to bank rombank using the MBC1 controller.\fR"
.PP
.in +1c

.ti -1c
.RI "
#define \fBSWITCH_RAM_MBC1\fR (b) "
.br
.ti -1c
.RI "
#define \fBSWITCH_ROM_MBC5\fR (b) "
.br
.RI "\fIMBC5.\fR"
.PP
.in +1c

.ti -1c
.RI "
#define \fBSWITCH_RAM_MBC5\fR (b) "
.br
.ti -1c
.RI "#define \fBDISPLAY_ON\fR"
.br
.RI "\fITurns the display back on.\fR"
.PP
.in +1c

.ti -1c
.RI "#define \fBDISPLAY_OFF\fR"
.br
.RI "\fITurns the display off immediatly.\fR"
.PP
.in +1c

.ti -1c
.RI "#define \fBSHOW_BKG\fR"
.br
.RI "\fITurns on the background layer.\fR"
.PP
.in +1c

.ti -1c
.RI "#define \fBHIDE_BKG\fR"
.br
.RI "\fITurns off the background layer.\fR"
.PP
.in +1c

.ti -1c
.RI "
#define \fBSHOW_WIN\fR"
.br
.RI "\fITurns on the window layer Sets bit 5 of the LCDC register to 1.\fR"
.PP
.in +1c

.ti -1c
.RI "#define \fBHIDE_WIN\fR"
.br
.RI "\fITurns off the window layer.\fR"
.PP
.in +1c

.ti -1c
.RI "#define \fBSHOW_SPRITES\fR"
.br
.RI "\fITurns on the sprites layer.\fR"
.PP
.in +1c

.ti -1c
.RI "#define \fBHIDE_SPRITES\fR"
.br
.RI "\fITurns off the sprites layer.\fR"
.PP
.in +1c

.ti -1c
.RI "#define \fBSPRITES_8x16\fR"
.br
.RI "\fISets sprite size to 8x16 pixels, two tiles one above the other.\fR"
.PP
.in +1c

.ti -1c
.RI "#define \fBSPRITES_8x8\fR"
.br
.RI "\fISets sprite size to 8x8 pixels, one tile.\fR"
.PP

.in -1c
.SS Typedefs

.in +1c
.ti -1c
.RI "
typedef void (* \fBint_handler\fR )(void) NONBANKED"
.br
.RI "\fIInterrupt handlers.\fR"
.PP

.in -1c
.SS Functions

.in +1c
.ti -1c
.RI "void \fBremove_VBL\fR (\fBint_handler\fR h) NONBANKED"
.br
.RI "\fIThe remove functions will remove any interrupt handler.\fR"
.PP
.in +1c

.ti -1c
.RI "
void \fBremove_LCD\fR (\fBint_handler\fR h) NONBANKED"
.br
.ti -1c
.RI "
void \fBremove_TIM\fR (\fBint_handler\fR h) NONBANKED"
.br
.ti -1c
.RI "
void \fBremove_SIO\fR (\fBint_handler\fR h) NONBANKED"
.br
.ti -1c
.RI "
void \fBremove_JOY\fR (\fBint_handler\fR h) NONBANKED"
.br
.ti -1c
.RI "void \fBadd_VBL\fR (\fBint_handler\fR h) NONBANKED"
.br
.RI "\fIAdds a V-blank interrupt handler.\fR"
.PP
.in +1c

.ti -1c
.RI "void \fBadd_LCD\fR (\fBint_handler\fR h) NONBANKED"
.br
.RI "\fIAdds a LCD interrupt handler.\fR"
.PP
.in +1c

.ti -1c
.RI "void \fBadd_TIM\fR (\fBint_handler\fR h) NONBANKED"
.br
.RI "\fIAdds a timer interrupt handler.\fR"
.PP
.in +1c

.ti -1c
.RI "void \fBadd_SIO\fR (\fBint_handler\fR h) NONBANKED"
.br
.RI "\fIAdds a serial transmit complete interrupt handler.\fR"
.PP
.in +1c

.ti -1c
.RI "void \fBadd_JOY\fR (\fBint_handler\fR h) NONBANKED"
.br
.RI "\fIAdds a pad tranisition interrupt handler.\fR"
.PP
.in +1c

.ti -1c
.RI "
void \fBmode\fR (\fBUINT8\fR m) NONBANKED"
.br
.RI "\fISet the current mode - one of M_* defined above.\fR"
.PP
.in +1c

.ti -1c
.RI "
\fBUINT8\fR \fBget_mode\fR (void) NONBANKED"
.br
.RI "\fIReturns the current mode.\fR"
.PP
.in +1c

.ti -1c
.RI "
void \fBsend_byte\fR (void)"
.br
.RI "\fISend byte in _io_out to the serial port.\fR"
.PP
.in +1c

.ti -1c
.RI "
void \fBreceive_byte\fR (void)"
.br
.RI "\fIReceive byte from the serial port in _io_in.\fR"
.PP
.in +1c

.ti -1c
.RI "void \fBdelay\fR (\fBUINT16\fR d) NONBANKED"
.br
.RI "\fIDelays the given number of milliseconds.\fR"
.PP
.in +1c

.ti -1c
.RI "\fBUINT8\fR \fBjoypad\fR (void) NONBANKED"
.br
.RI "\fIReads and returns the current state of the joypad.\fR"
.PP
.in +1c

.ti -1c
.RI "\fBUINT8\fR \fBwaitpad\fR (\fBUINT8\fR mask) NONBANKED"
.br
.RI "\fIWaits until all the keys given in mask are pressed.\fR"
.PP
.in +1c

.ti -1c
.RI "
void \fBwaitpadup\fR (void) NONBANKED"
.br
.RI "\fIWaits for the pad and all buttons to be released.\fR"
.PP
.in +1c

.ti -1c
.RI "void \fBenable_interrupts\fR (void) NONBANKED"
.br
.RI "\fIEnables unmasked interrupts.\fR"
.PP
.in +1c

.ti -1c
.RI "void \fBdisable_interrupts\fR (void) NONBANKED"
.br
.RI "\fIDisables interrupts.\fR"
.PP
.in +1c

.ti -1c
.RI "void \fBset_interrupts\fR (\fBUINT8\fR flags) NONBANKED"
.br
.RI "\fIClears any pending interrupts and sets the interrupt mask register IO to flags.\fR"
.PP
.in +1c

.ti -1c
.RI "
void \fBreset\fR (void) NONBANKED"
.br
.RI "\fIPerforms a warm reset by reloading the CPU value then jumping to the start of crt0 (0x0150).\fR"
.PP
.in +1c

.ti -1c
.RI "void \fBwait_vbl_done\fR (void) NONBANKED"
.br
.RI "\fIWaits for the vertical blank interrupt (VBL) to finish.\fR"
.PP
.in +1c

.ti -1c
.RI "void \fBdisplay_off\fR (void) NONBANKED"
.br
.RI "\fITurns the display off.\fR"
.PP
.in +1c

.ti -1c
.RI "void \fBhiramcpy\fR (\fBUINT8\fR dst, const void *src, \fBUINT8\fR n) NONBANKED"
.br
.RI "\fICopies data from somewhere in the lower address space to part of hi-ram.\fR"
.PP
.in +1c

.ti -1c
.RI "void \fBset_bkg_data\fR (\fBUINT8\fR first_tile, \fBUINT8\fR nb_tiles, unsigned char *data) NONBANKED"
.br
.RI "\fISets the tile patterns in the Background Tile Pattern table.\fR"
.PP
.in +1c

.ti -1c
.RI "void \fBset_bkg_tiles\fR (\fBUINT8\fR x, \fBUINT8\fR y, \fBUINT8\fR w, \fBUINT8\fR h, unsigned char *tiles) NONBANKED"
.br
.RI "\fISets the tiles in the background tile table.\fR"
.PP
.in +1c

.ti -1c
.RI "
void \fBget_bkg_tiles\fR (\fBUINT8\fR x, \fBUINT8\fR y, \fBUINT8\fR w, \fBUINT8\fR h, unsigned char *tiles) NONBANKED"
.br
.ti -1c
.RI "void \fBmove_bkg\fR (\fBUINT8\fR x, \fBUINT8\fR y) NONBANKED"
.br
.RI "\fIMoves the background layer to the position specified in x and y in pixels.\fR"
.PP
.in +1c

.ti -1c
.RI "void \fBscroll_bkg\fR (\fBINT8\fR x, \fBINT8\fR y) NONBANKED"
.br
.RI "\fIMoves the background relative to it's current position.\fR"
.PP
.in +1c

.ti -1c
.RI "void \fBset_win_data\fR (\fBUINT8\fR first_tile, \fBUINT8\fR nb_tiles, unsigned char *data) NONBANKED"
.br
.RI "\fISets the window tile data.\fR"
.PP
.in +1c

.ti -1c
.RI "void \fBset_win_tiles\fR (\fBUINT8\fR x, \fBUINT8\fR y, \fBUINT8\fR w, \fBUINT8\fR h, unsigned char *tiles) NONBANKED"
.br
.RI "\fISets the tiles in the win tile table.\fR"
.PP
.in +1c

.ti -1c
.RI "
void \fBget_win_tiles\fR (\fBUINT8\fR x, \fBUINT8\fR y, \fBUINT8\fR w, \fBUINT8\fR h, unsigned char *tiles) NONBANKED"
.br
.ti -1c
.RI "void \fBmove_win\fR (\fBUINT8\fR x, \fBUINT8\fR y) NONBANKED"
.br
.RI "\fIMoves the window layer to the position specified in x and y in pixels.\fR"
.PP
.in +1c

.ti -1c
.RI "void \fBscroll_win\fR (\fBINT8\fR x, \fBINT8\fR y) NONBANKED"
.br
.RI "\fIMove the window relative to its current position.\fR"
.PP
.in +1c

.ti -1c
.RI "void \fBset_sprite_data\fR (\fBUINT8\fR first_tile, \fBUINT8\fR nb_tiles, unsigned char *data) NONBANKED"
.br
.RI "\fISets the tile patterns in the Sprite Tile Pattern table.\fR"
.PP
.in +1c

.ti -1c
.RI "
void \fBget_sprite_data\fR (\fBUINT8\fR first_tile, \fBUINT8\fR nb_tiles, unsigned char *data) NONBANKED"
.br
.ti -1c
.RI "void \fBset_sprite_tile\fR (\fBUINT8\fR nb, \fBUINT8\fR tile) NONBANKED"
.br
.RI "\fISets sprite n to display tile number t, from the sprite tile data.\fR"
.PP
.in +1c

.ti -1c
.RI "
\fBUINT8\fR \fBget_sprite_tile\fR (\fBUINT8\fR nb) NONBANKED"
.br
.ti -1c
.RI "void \fBset_sprite_prop\fR (\fBUINT8\fR nb, \fBUINT8\fR prop) NONBANKED"
.br
.RI "\fISets the property of sprite n to those defined in p.\fR"
.PP
.in +1c

.ti -1c
.RI "
\fBUINT8\fR \fBget_sprite_prop\fR (\fBUINT8\fR nb) NONBANKED"
.br
.ti -1c
.RI "void \fBmove_sprite\fR (\fBUINT8\fR nb, \fBUINT8\fR x, \fBUINT8\fR y) NONBANKED"
.br
.RI "\fIMoves the given sprite to the given position on the screen.\fR"
.PP
.in +1c

.ti -1c
.RI "
void \fBscroll_sprite\fR (\fBINT8\fR nb, \fBINT8\fR x, \fBINT8\fR y) NONBANKED"
.br
.RI "\fIMoves the given sprite relative to its current position.\fR"
.PP
.in +1c

.ti -1c
.RI "
void \fBset_data\fR (unsigned char *vram_addr, unsigned char *data, \fBUINT16\fR len) NONBANKED"
.br
.ti -1c
.RI "
void \fBget_data\fR (unsigned char *data, unsigned char *vram_addr, \fBUINT16\fR len) NONBANKED"
.br
.ti -1c
.RI "
void \fBset_tiles\fR (\fBUINT8\fR x, \fBUINT8\fR y, \fBUINT8\fR w, \fBUINT8\fR h, unsigned char *vram_addr, unsigned char *tiles) NONBANKED"
.br
.ti -1c
.RI "
void \fBget_tiles\fR (\fBUINT8\fR x, \fBUINT8\fR y, \fBUINT8\fR w, \fBUINT8\fR h, unsigned char *tiles, unsigned char *vram_addr) NONBANKED"
.br
.in -1c
.SS Variables

.in +1c
.ti -1c
.RI "
\fBUINT8\fR \fB_cpu\fR"
.br
.RI "\fIGB type (GB, PGB, CGB).\fR"
.PP
.in +1c

.ti -1c
.RI "
\fBUINT16\fR \fBsys_time\fR"
.br
.RI "\fITime in VBL periods (60Hz).\fR"
.PP
.in +1c

.ti -1c
.RI "
\fBUINT8\fR \fB_io_status\fR"
.br
.RI "\fIAn OR of IO_*.\fR"
.PP
.in +1c

.ti -1c
.RI "
\fBUINT8\fR \fB_io_in\fR"
.br
.RI "\fIByte just read.\fR"
.PP
.in +1c

.ti -1c
.RI "\fBUINT8\fR \fB_io_out\fR"
.br
.RI "\fIWrite the byte to send here before calling \fBsend_byte\fR().\fR"
.PP

.in -1c
.SH DETAILED DESCRIPTION
.PP 
Gameboy specific functions.
.SH DEFINE DOCUMENTATION
.PP 
.SS #define J_START ()
.PP
Joypad bits.
.PP
A logical OR of these is used in the wait_pad and joypad functions. For example, to see if the B button is pressed try
.PP
UINT8 keys; keys = \fBjoypad\fR(); if (keys & J_B) { ... }
.PP
\fBSee also: \fR
.in +1c
\fBjoypad\fR() 
.SS #define M_DRAWING ()
.PP
Screen modes.
.PP
Normally used by internal functions only. 
.SS #define S_PALETTE ()
.PP
If this is set, sprite colours come from OBJ1PAL.
.PP
Else they come from OBJ0PAL. 
.SS #define VBL_IFLAG ()
.PP
Vertical blank interrupt.
.PP
Occurs at the start of the vertical blank. During this period the video ram may be freely accessed. 
.SS #define LCD_IFLAG ()
.PP
Interrupt when triggered by the STAT register.
.PP
See the Pan doc. 
.SS #define SWITCH_ROM_MBC1 (b)
.PP
Switches the upper 16k bank of the 32k rom to bank rombank using the MBC1 controller.
.PP
By default the upper 16k bank is 1. Make sure the rom you compile has more than just bank 0 and bank 1, a 32k rom. This is done by feeding lcc.exe the following switches:
.PP
-Wl-yt# where # is the type of cartridge. 1 for ROM+MBC1.
.PP
-Wl-yo# where # is the number of rom banks. 2,4,8,16,32. 
.SS #define DISPLAY_ON ()
.PP
Turns the display back on.
.PP
\fBSee also: \fR
.in +1c
\fBdisplay_off\fR(), \fBDISPLAY_OFF\fR() 
.SS #define DISPLAY_OFF ()
.PP
Turns the display off immediatly.
.PP
\fBSee also: \fR
.in +1c
\fBdisplay_off\fR(), \fBDISPLAY_ON\fR() 
.SS #define SHOW_BKG ()
.PP
Turns on the background layer.
.PP
Sets bit 0 of the LCDC register to 1. 
.SS #define HIDE_BKG ()
.PP
Turns off the background layer.
.PP
Sets bit 0 of the LCDC register to 0. 
.SS #define HIDE_WIN ()
.PP
Turns off the window layer.
.PP
Clears bit 5 of the LCDC register to 0. 
.SS #define SHOW_SPRITES ()
.PP
Turns on the sprites layer.
.PP
Sets bit 1 of the LCDC register to 1. 
.SS #define HIDE_SPRITES ()
.PP
Turns off the sprites layer.
.PP
Clears bit 1 of the LCDC register to 0. 
.SS #define SPRITES_8x16 ()
.PP
Sets sprite size to 8x16 pixels, two tiles one above the other.
.PP
Sets bit 2 of the LCDC register to 1. 
.SS #define SPRITES_8x8 ()
.PP
Sets sprite size to 8x8 pixels, one tile.
.PP
Clears bit 2 of the LCDC register to 0. 
.SH FUNCTION DOCUMENTATION
.PP 
.SS void remove_VBL (\fBint_handler\fR h)
.PP
The remove functions will remove any interrupt handler.
.PP
A handler of NULL will cause bad things to happen. 
.SS void add_VBL (\fBint_handler\fR h)
.PP
Adds a V-blank interrupt handler.
.PP
The handler 'h' will be called whenever a V-blank interrupt occurs. Up to 4 handlers may be added, with the last added being called last. If the remove_VBL function is to be called, only three may be added. 
.PP
\fBSee also: \fR
.in +1c
\fBremove_VBL\fR() 
.SS void add_LCD (\fBint_handler\fR h)
.PP
Adds a LCD interrupt handler.
.PP
Called when the LCD interrupt occurs, which is normally when LY_REG == LYC_REG.
.PP
From pan/k0Pa: There are various reasons for this interrupt to occur as described by the STAT register ($FF40). One very popular reason is to indicate to the user when the video hardware is about to redraw a given LCD line. This can be useful for dynamically controlling the SCX/ SCY registers ($FF43/$FF42) to perform special video effects.
.PP
\fBSee also: \fR
.in +1c
\fBadd_VBL\fR() 
.SS void add_TIM (\fBint_handler\fR h)
.PP
Adds a timer interrupt handler.
.PP
From pan/k0Pa: This interrupt occurs when the TIMA register ($FF05) changes from $FF to $00.
.PP
\fBSee also: \fR
.in +1c
\fBadd_VBL\fR() 
.SS void add_SIO (\fBint_handler\fR h)
.PP
Adds a serial transmit complete interrupt handler.
.PP
From pan/k0Pa: This interrupt occurs when a serial transfer has completed on the game link port.
.PP
\fBSee also: \fR
.in +1c
\fBsend_byte\fR(), \fBreceive_byte\fR(), \fBadd_VBL\fR() 
.SS void add_JOY (\fBint_handler\fR h)
.PP
Adds a pad tranisition interrupt handler.
.PP
From pan/k0Pa: This interrupt occurs on a transition of any of the keypad input lines from high to low. Due to the fact that keypad "bounce" is virtually always present, software should expect this interrupt to occur one or more times for every button press and one or more times for every button release.
.PP
\fBSee also: \fR
.in +1c
\fBjoypad\fR() 
.SS void delay (\fBUINT16\fR d)
.PP
Delays the given number of milliseconds.
.PP
Uses no timers or interrupts, and can be called with interrupts disabled (why nobody knows :) 
.SS \fBUINT8\fR joypad (void)
.PP
Reads and returns the current state of the joypad.
.PP
Follows Nintendo's guidelines for reading the pad. Return value is an OR of J_* 
.PP
\fBSee also: \fR
.in +1c
\fBJ_START\fR() 
.SS \fBUINT8\fR waitpad (\fBUINT8\fR mask)
.PP
Waits until all the keys given in mask are pressed.
.PP
Normally only used for checking one key, but it will support many, even J_LEFT at the same time as J_RIGHT :) 
.PP
\fBSee also: \fR
.in +1c
\fBjoypad\fR(), \fBJ_START\fR() 
.SS void enable_interrupts (void)
.PP
Enables unmasked interrupts.
.PP
\fBSee also: \fR
.in +1c
\fBdisable_interrupts\fR() 
.SS void disable_interrupts (void)
.PP
Disables interrupts.
.PP
This function may be called as many times as you like; however the first call to enable_interrupts will re-enable them. 
.PP
\fBSee also: \fR
.in +1c
\fBenable_interrupts\fR() 
.SS void set_interrupts (\fBUINT8\fR flags)
.PP
Clears any pending interrupts and sets the interrupt mask register IO to flags.
.PP
\fBSee also: \fR
.in +1c
\fBVBL_IFLAG\fR() 
.PP
\fBParameters: \fR
.in +1c
.TP
\fB\fIflags\fR\fR A logical OR of *_IFLAGS 
.SS void wait_vbl_done (void)
.PP
Waits for the vertical blank interrupt (VBL) to finish.
.PP
This can be used to sync animation with the screen re-draw. If VBL interrupt is disabled, this function will never return. If the screen is off this function returns immediatly. 
.SS void display_off (void)
.PP
Turns the display off.
.PP
Waits until the VBL interrupt before turning the display off. 
.PP
\fBSee also: \fR
.in +1c
\fBDISPLAY_ON\fR() 
.SS void hiramcpy (\fBUINT8\fR dst, const void * src, \fBUINT8\fR n)
.PP
Copies data from somewhere in the lower address space to part of hi-ram.
.PP
\fBParameters: \fR
.in +1c
.TP
\fB\fIdst\fR\fR Offset in high ram (0xFF00 and above) to copy to. 
.TP
\fB\fIsrc\fR\fR Area to copy from 
.TP
\fB\fIn\fR\fR Number of bytes to copy. 
.SS void set_bkg_data (\fBUINT8\fR first_tile, \fBUINT8\fR nb_tiles, unsigned char * data)
.PP
Sets the tile patterns in the Background Tile Pattern table.
.PP
Starting with the tile pattern x and carrying on for n number of tile patterns.Taking the values starting from the pointer data. Note that patterns 128-255 overlap with patterns 128-255 of the sprite Tile Pattern table.
.PP
GBC: Depending on the VBK_REG this determines which bank of Background tile patterns are written to. VBK_REG=0 indicates the first bank, and VBK_REG=1 indicates the second.
.PP
\fBParameters: \fR
.in +1c
.TP
\fB\fIfirst_tile\fR\fR Range 0 - 255 
.TP
\fB\fInb_tiles\fR\fR Range 0 - 255 
.SS void set_bkg_tiles (\fBUINT8\fR x, \fBUINT8\fR y, \fBUINT8\fR w, \fBUINT8\fR h, unsigned char * tiles)
.PP
Sets the tiles in the background tile table.
.PP
Starting at position x,y in tiles and writing across for w tiles and down for h tiles. Taking the values starting from the pointer data.
.PP
For the GBC, also see the pan/k00Pa section on VBK_REG.
.PP
\fBParameters: \fR
.in +1c
.TP
\fB\fIx\fR\fR Range 0 - 31 
.TP
\fB\fIy\fR\fR Range 0 - 31 
.TP
\fB\fIw\fR\fR Range 0 - 31 
.TP
\fB\fIh\fR\fR Range 0 - 31 
.TP
\fB\fIdata\fR\fR Pointer to an unsigned char. Usually the first element in an array. 
.SS void move_bkg (\fBUINT8\fR x, \fBUINT8\fR y)
.PP
Moves the background layer to the position specified in x and y in pixels.
.PP
Where 0,0 is the top left corner of the GB screen. You'll notice the screen wraps around in all 4 directions, and is always under the window layer. 
.SS void scroll_bkg (\fBINT8\fR x, \fBINT8\fR y)
.PP
Moves the background relative to it's current position.
.PP
\fBSee also: \fR
.in +1c
\fBmove_bkg\fR() 
.SS void set_win_data (\fBUINT8\fR first_tile, \fBUINT8\fR nb_tiles, unsigned char * data)
.PP
Sets the window tile data.
.PP
This is the same as set_bkg_data, as both the window layer and background layer share the same Tile Patterns. 
.PP
\fBSee also: \fR
.in +1c
\fBset_bkg_data\fR() 
.SS void set_win_tiles (\fBUINT8\fR x, \fBUINT8\fR y, \fBUINT8\fR w, \fBUINT8\fR h, unsigned char * tiles)
.PP
Sets the tiles in the win tile table.
.PP
Starting at position x,y in tiles and writing across for w tiles and down for h tiles. Taking the values starting from the pointer data. Note that patterns 128-255 overlap with patterns 128-255 of the sprite Tile Pattern table.
.PP
GBC only. Depending on the VBK_REG this determines if you're setting the tile numbers VBK_REG=0; or the attributes for those tiles VBK_REG=1;. The bits in the attributes are defined as: Bit 7 - Priority flag. When this is set, it puts the tile above the sprites with colour 0 being transparent. 0: below sprites, 1: above sprites Note SHOW_BKG needs to be set for these priorities to take place. Bit 6 - Vertical flip. Dictates which way up the tile is drawn vertically. 0: normal, 1: upside down. Bit 5 - Horizontal flip. Dictates which way up the tile is drawn horizontally. 0: normal, 1:back to front. Bit 4 - Not used. Bit 3 - Character Bank specification. Dictates from which bank of Background Tile Patterns the tile is taken. 0: Bank 0, 1: Bank 1 Bit 2 - See bit 0. Bit 1 - See bit 0. Bit 0 - Bits 0-2 indicate which of the 7 BKG colour palettes the tile is assigned.
.PP
\fBParameters: \fR
.in +1c
.TP
\fB\fIx\fR\fR Range 0 - 31 
.TP
\fB\fIy\fR\fR Range 0 - 31 
.TP
\fB\fIw\fR\fR Range 0 - 31 
.TP
\fB\fIh\fR\fR Range 0 - 31 
.SS void move_win (\fBUINT8\fR x, \fBUINT8\fR y)
.PP
Moves the window layer to the position specified in x and y in pixels.
.PP
Where 7,0 is the top left corner of the GB screen. The window is locked to the bottom right corner, and is always over the background layer. 
.PP
\fBSee also: \fR
.in +1c
\fBSHOW_WIN\fR(), \fBHIDE_WIN\fR() 
.SS void scroll_win (\fBINT8\fR x, \fBINT8\fR y)
.PP
Move the window relative to its current position.
.PP
\fBSee also: \fR
.in +1c
\fBmove_win\fR() 
.SS void set_sprite_data (\fBUINT8\fR first_tile, \fBUINT8\fR nb_tiles, unsigned char * data)
.PP
Sets the tile patterns in the Sprite Tile Pattern table.
.PP
Starting with the tile pattern x and carrying on for n number of tile patterns.Taking the values starting from the pointer data. Note that patterns 128-255 overlap with patterns 128-255 of the Background Tile Pattern table.
.PP
GBC only. Depending on the VBK_REG this determines which bank of Background tile patterns are written to. VBK_REG=0 indicates the first bank, and VBK_REG=1 indicates the second. 
.SS void set_sprite_tile (\fBUINT8\fR nb, \fBUINT8\fR tile)
.PP
Sets sprite n to display tile number t, from the sprite tile data.
.PP
If the GB is in 8x16 sprite mode then it will display the next tile, t+1, below the first tile. 
.PP
\fBParameters: \fR
.in +1c
.TP
\fB\fInb\fR\fR Sprite number, range 0 - 39 
.SS void set_sprite_prop (\fBUINT8\fR nb, \fBUINT8\fR prop)
.PP
Sets the property of sprite n to those defined in p.
.PP
Where the bits in p represent: Bit 7 - Priority flag. When this is set the sprites appear behind the background and window layer. 0: infront, 1: behind. Bit 6 - GBC only. Vertical flip. Dictates which way up the sprite is drawn vertically. 0: normal, 1:upside down. Bit 5 - GBC only. Horizontal flip. Dictates which way up the sprite is drawn horizontally. 0: normal, 1:back to front. Bit 4 - DMG only. Assigns either one of the two b/w palettes to the sprite. 0: OBJ palette 0, 1: OBJ palette 1. Bit 3 - GBC only. Dictates from which bank of Sprite Tile Patterns the tile is taken. 0: Bank 0, 1: Bank 1 Bit 2 - See bit 0. Bit 1 - See bit 0. Bit 0 - GBC only. Bits 0-2 indicate which of the 7 OBJ colour palettes the sprite is assigned.
.PP
\fBParameters: \fR
.in +1c
.TP
\fB\fInb\fR\fR Sprite number, range 0 - 39 
.SS void move_sprite (\fBUINT8\fR nb, \fBUINT8\fR x, \fBUINT8\fR y)
.PP
Moves the given sprite to the given position on the screen.
.PP
Dont forget that the top left visible pixel on the screen is at (8,16). To put sprite 0 at the top left, use move_sprite(0, 8, 16); 
.SH VARIABLE DOCUMENTATION
.PP 
.SS \fBUINT8\fR _io_out
.PP
Write the byte to send here before calling \fBsend_byte\fR().
.PP
\fBSee also: \fR
.in +1c
\fBsend_byte\fR() 
.SH AUTHOR
.PP 
Generated automatically by Doxygen for gbdk-lib from the source code.